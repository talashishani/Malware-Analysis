# Malware-Analysis

The purpose of malware analysis is usually to provide the information you need to respond to a network intrusion. Your goals will typically be to determine exactly what happened, and to ensure that you’ve located all infected machines and files. When analyzing suspected malware, your goal will typically be to determine exactly what a particular suspect binary can do, how to detect it on your network, and how to measure and contain its damage.

This file containes a Yara Rule to detect the attached malware.

The malware only uses one library, which is MSVBVM60.DLL

The Malware is Portable Executable (PE) and runs on Windows – we know this using the magic
code (MZ)

The executable program is malicious since:  It generates a fake error message and it is obfuscated.

The malware was written in visual basic, there is a delay imports detected, and it was created on December 26th, 2022. 

The malware will be accessing the internet. It seems like that the malware will create a registry key. WScript.Shell is also usually associated with executing shell scripts.


## Malware rar file

The Password for the Malware is `infected`

## Static-Analysis

Static malware analysis is the process of analyzing malware without executing it. This can include examining the code and binaries of a program, as well as analyzing metadata such as file headers and other information embedded in the file. The goal of static analysis is to identify malware characteristics, such as the presence of known malicious code or indicators of malicious behavior. It can also be used to determine the functionality of the malware and its potential impact on a system. This method is considered less risky than dynamic analysis, which involves actually running the malware in a controlled environment, but it can be more difficult to extract actionable information from the malware.

### Hashing

> SHA-256: 3c09c7591a85f674b033c17f7d80535963f179b4fcd7fe2aba5f2ec5d6813405

> MD5: 6147b3df04d5d93d9186f3ede6e74b71

VirusTotal:

![virustotal](https://user-images.githubusercontent.com/123273646/213929571-4e8ee456-a99b-45a7-b762-1269da9f919c.png)

### Strings

To get an idea of the strings embedded in the malware, `floss` is being used against the executable file.

![floss](https://user-images.githubusercontent.com/123273646/213929608-9e3ea0e9-2bc1-4c88-893f-0a816d1c2186.png)


```
CaesarCipher
intShift
PSUT.dll is missing!
C:\windows\updator.exe
@*\AC:\Users\Haitham\Desktop\AAAA\Project1.vbp
C:\Users\Hacked.txt
http://www.example.com/post_handler
WScript.Shell
HKEY_CURRENT_USER\Software\MyApp\Key
https://www.google.com
```

Based on the strings found, we can predict that the malware will be accessing the internet. We can also see that the malware has been written in Visual Basic. It also seems like that the malware will modify/create a registry key. `WScript.Shell` is also usually associated with executing shell scripts.

### PEview

It came to my attention that the virtual size and size of raw data values are slightly, therefore that difference is not alarming, so the malware is probably not packed.

![size](https://user-images.githubusercontent.com/123273646/213929652-ac333254-b441-428f-8f43-b2ff874dfaf6.png)

### PEstudio

Opening the malware with PEstudio gives a more ordered overview of the malware. The malware only uses one library, which is `MSVBVM60.DLL`. 

![PE](https://user-images.githubusercontent.com/123273646/213929691-267675d3-157d-46dd-bd19-6111634972c8.png)

## Dynamic Analysis

Dynamic malware analysis is the process of analyzing malware by executing it in a controlled environment. This method allows for the observation of the malware's behavior, such as network communication and file system changes, as well as the identification of any additional malicious components that may not be visible through static analysis. The goal of dynamic analysis is to identify the full range of the malware's capabilities and its potential impact on a system. This method is considered more risky than static analysis, as the malware could potentially harm the analysis environment, but it can provide more information about the malware's capabilities. There are multiple approaches to dynamic analysis such as sandboxing, virtualization, and dynamic instrumentation.

Before running the malware, the `inetsim` service should be running on the Remnux machine to simulate an internet connection, should the malware check for internet connectivity. In addition to `inetsim`, capturing packets coming from the malware trying to connect to the “internet.” shall be listened to.

ProcMon and TCPview are prepared with a filter looking for a process with a process name of “Unknown_Malware.exe” so that what the malware is doing upon execution shall be seen.

The following message box appears upon running the malware:

![MSG1](https://user-images.githubusercontent.com/123273646/213929852-df217adc-0b1f-4100-beef-8def7388105f.png)

Clicking on “OK” results in another program showing another message box:

![MSG2](https://user-images.githubusercontent.com/123273646/213929867-e8238865-778b-480e-ae2d-db3113678723.png)

The second program’s name is “updator.exe”, which have been seen while performing the static analysis. The new program’s name shall be added to ProcMon’s filters so that it shows both the first and second executables behavior.

![PROCMON](https://user-images.githubusercontent.com/123273646/213929881-018aaad9-be15-4709-9f7e-0afa3bdcf962.png)

The malware seems to know that the supplied internet connection using `inetsim` is not as real enough. Looking through the traffic in Wireshark on Remnux:

![WIRESHARK1](https://user-images.githubusercontent.com/123273646/213929896-362cfe6d-e868-4cea-aba0-9d6388ccf923.png)

The malware is querying Google’s IP address, and the `inetsim` is responding to its request. Another thing that’s happening is a TLSv1.2 handshake happening between the `inetsim` and the malware. Although the handshake seems to be complete, the malware must have known that `inetsim`'s certificate is not legit. This problem can be solved by disabling HTTPS and SMTPS services in `inetsim`, and using [PolarProxy](https://www.netresec.com/?page=Blog&month=2019-12&post=Installing-a-Fake-Internet-with-INetSim-and-PolarProxy).

![WIRESHARK2](https://user-images.githubusercontent.com/123273646/213929903-17a59a1a-e892-478a-950e-b9bdbd8eba2f.png)

After installing the TLS certificate on the Windows machine, running the malware does not show the “No internet. No game” message box, which means that it connected to the `inetsim` successfully. Looking through ProcMon, the process “updator.exe” has created a registry key “HKEY_CURRENT_USER\Software\MyApp\Key” and modified its value, and downloaded a file and saved it as “Hacked.txt”
The contents of the file “Hacked.txt” are as follows:

![TEXTFILE](https://user-images.githubusercontent.com/123273646/213929927-4e52d1d1-3346-4a94-9967-a8f7b7ca8092.png)

It seems that the string “CaesarCipher” is hinting that the file is encrypted using the Caesar Cipher algorithm. Testing all possible shifts at [dcode.fr](http://dcode.fr) results in the following string when shifting the encrypted text 4 characters to the left:

```
Computer$Name>$DESKTOP1E=TODRB
Private$IP>$54242428
```

It can be seen that the modified value of the registry key created by “updator.exe” is also 4, which might reflect the Caesar Cipher algorithm’s shift.

In addition, looking at the traffic in Wireshark, it seems that the malware requested to download the file “connecttest.txt” to ensure network connectivity, which is provided by the `inetsim`.

![WIRESHARK3](https://user-images.githubusercontent.com/123273646/213929944-f2e7d476-fa7a-4b52-b12f-9164c87b3142.png)

## YARA Rule

YARA is a tool that allows for the identification and classification of malware based on its characteristics. It does this by using "rules" that specify patterns to search for in files or network traffic. These patterns can include strings of text, binary data, or even regular expressions. YARA rules can be used to match a wide range of information, including file headers, imports, exports, and strings within the binary.

A YARA rule consists of three main parts:

  1) rule name: The name of the rule, which is used to identify it.
  2) set of conditions: The conditions that must be met for the rule to match. These conditions are specified using strings, hexadecimal strings, regular expressions, or            other special operators.
  3) set of metadata: Additional information about the rule, such as the author or a description of the malware family it is associated with.

YARA rules can be used for both static and dynamic malware analysis, and also can be used as a signature-based scanner for detecting known malware. YARA can be integrated with other tools and frameworks such as malware sandboxes and endpoint protection platforms, to increase its effectiveness.



```

rule malware_detection_strings {
    meta:
        description = "YARA Rule to detect Unknown_Malware.rar"
        author = "Tala Shishani"
 
    strings:
        $CaesarCipher = "CaesarCipher"
        $intShift = "intShift"
        $PSUTdll = "PSUT.dll is missing!"
        $updator = "C:\\windows\\updator.exe"
        $desktop = "@*\\AC:\\Users\\Haitham\\Desktop\\AAAA\\Project1.vbp"
        $hacked = "C:\\Users\\Hacked.txt"
        $post_handler = "http://www.example.com/post_handler"
        $regkey = "HKEY_CURRENT_USER\\Software\\MyApp\\Key"
        $google = "https://www.google.com"
    condition:
        uint16(0) == 0x5A4D and all of them
}

```

![Tala](https://user-images.githubusercontent.com/123273646/213930260-d686311f-ee7b-4fb7-99f3-8df7a66685e1.png)




